#####################################################################################################################
#														TP1 GRI														#
#####################################################################################################################


M2 INFORMATIQUE PARIS DIDEROT - 2017/2018
AUVERT RAPHAEL
LABADENS LUCAS


légende README:
	CC : composante connexe

pour compiler :
	javac *.java

Pour éxecuter:
	java Exo1 [nom_du_fichier] [-o]
		-o: pour un graph orienté

	java Exo2 [nom_du_fichier] [sommet_D] [-o] [-v] [-f]
		-o: pour un graph orienté
		-f: pour un fichier de sortit avec la liste des sommes dans l'ordre du parcours en largeur depuis le sommet D
		-v: pour un mode verbose



#####################################################################################################################
#													Explication Exo2												#
#####################################################################################################################


Complexité en temps :
	O(n * log(n))  dans le cas ou la hashmap est lourdement rempli

Compelxité en espace :
	O(  n*D + k)
	
	n le nombre de sommets
	D degrée du sommet n
	k le nombre de CC

une implemntation JAVA est proposé :
	Un seul et unique parcout du fichier 
	Un seul et unique parcour en largeur du graph

Une implementation la plus legere possible en memoire est proposé :

	- Nous l'avons adapté pour repondre au pire cas ( quand il y a enormement de trous d'id dans le graph avec un idMax trés grand , afin de ne pas avoir une complexcité en memoire qui puisse explosé )


La structure de donnée est une :
	LinkedHasMap de (clef,valeur) -> (idSommet , Sommet)
	Nous avons un Ierateur en O(1) pour l'operation Next


Chaque sommet stock une liste de ces voisins accessibles 
		+ dans le cas orient :
			 une reference vers la CC associé , chaque CC a une reference vers sa CC pere associe durant le parcout


---------------------------------------
Algorithme en largeur

	Sommet S

	Tant que pas tout sommet visité:

		si premiere passe :
			S = sommet passé en argument

		sinon :
			S = un sommet pas deja visité (on parcour la LinkedhasMap juqu'au prochain sommet non deja visité)

		dans la cas orienté:
			on cree une nouvelle id de CC noté CC*
			on associe a S la CC*

		on lance un parcour en largeur depuis S:

			dans la cas orienté:
				si un sommet voisin Sv possede une id de CC
					
					pere =find(CC)    (pour trouver la CC pere)
					
					si pere differente de CC*
						Sv.CC.pere = CC*

				sinon lui associé la CC*

