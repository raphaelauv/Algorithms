#####################################################################################################################
#														TP1 GRI														#
#####################################################################################################################


M2 INFORMATIQUE PARIS DIDEROT - 2017/2018
AUVERT RAPHAEL
LABADENS LUCAS


légende du README:
	CC -> composante connexe

#####################################################################################################################

pour COMPILER :
	javac *.java

#####################################################################################################################

Pour éxecuter:
	java Exo1 [nom_du_fichier] [-o]
		-o: pour un graph orienté

	java Exo2 [nom_du_fichier] [sommet_D] [-o] [-v] [-f]
		-o: pour un graph orienté
		-f: pour un fichier de sortit avec la liste des sommes dans l'ordre du parcours en largeur depuis le sommet D
		-v: pour un mode verbose



#####################################################################################################################
#													Explication Exo2												#
#####################################################################################################################


Complexité en temps :

	Dans le cas Pire :
		ou la hashmap est lourdement rempli et tres peu optimal

		O(d * log(n) * w(n) ) 

	  	d le nombre d'arc
	  	n le nombre de sommet
	  	w(n) complexité de UNION-FIND optimal


	 
	Dans le cas Amortie :
		0( d * w(n) )


#####################################################################################################################

Complexité en espace :
	O(  d + k + p)
	
	d le nombre d'arc
	k le nombre de CC
	p la pile , au max n

#####################################################################################################################

une implemntation JAVA est proposé :
	Un seul et unique parcout du fichier 
	Un seul et unique parcour en largeur du graph

Une implementation la plus legere possible en memoire est proposé avec comme contraine :

	- Nous l'avons adapté pour repondre au pire cas ( quand il y a enormement de trous d'id dans le graph avec un idMax trés grand , afin de ne pas avoir une complexcité en memoire qui puisse explosé )

	- Pour le graph orienté : n'est pas stocker la liste des sommets entrants dans chaque sommet

		Chaque sommet stock un id de CC atribué et une reference vers la CC pere ( null au depart )
		un "UNION FIND" pendant le parcour en largeur permet le calcul des CC (avec compression du chemin vers la CC pere)


La structure de donnée est uniquement une :

	LinkedHasMap de (clef,valeur) -> (idSommet , Sommet)
		Nous avons un Ierateur en O(1) pour l'operation Next


Chaque sommet stock une liste de ces voisins accessibles 
		+ dans le cas orient :
			 une reference vers la CC associé , chaque CC a une reference vers sa CC pere associe durant le parcout


#####################################################################################################################
Algorithme en largeur

	Sommet S

	Tant que pas tout sommet visité:

		si premiere passe :
			S = sommet passé en argument

		sinon :
			S = un sommet pas deja visité (on parcour la LinkedhasMap juqu'au prochain sommet non deja visité)

		dans la cas orienté:
			on cree une nouvelle id de CC noté CC*
			on associe a S la CC*

		on lance un parcour en largeur depuis S:

			dans la cas orienté:
				si un sommet voisin Sv possede une id de CC
					
					pere =find(CC)    (pour trouver la CC pere)
					
					si pere differente de CC*
						Sv.CC.pere = CC*

				sinon lui associé la CC*

#####################################################################################################################

